{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushToTalkButton = void 0;\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar react_client_1 = require(\"@speechly/react-client\");\n\nvar pubsub_js_1 = __importDefault(require(\"pubsub-js\"));\n\nvar types_1 = require(\"../types\");\n\nvar HintCallout_1 = require(\"./HintCallout\");\n\nrequire(\"@speechly/browser-ui/holdable-button\");\n\nvar PushToTalkButton = function (_a) {\n  var captureKey = _a.captureKey,\n      _b = _a.size,\n      size = _b === void 0 ? '6.0rem' : _b,\n      _c = _a.gradientStops,\n      gradientStops = _c === void 0 ? ['#15e8b5', '#4fa1f9'] : _c;\n\n  var _d = react_client_1.useSpeechContext(),\n      speechState = _d.speechState,\n      toggleRecording = _d.toggleRecording,\n      initialise = _d.initialise;\n\n  var _e = react_1.useState(react_client_1.SpeechState.Idle),\n      icon = _e[0],\n      setIcon = _e[1];\n\n  var buttonRef = react_1.useRef();\n  var speechStateRef = react_1.useRef(); // make stateRef always have the current count\n  // your \"fixed\" callbacks can refer to this object whenever\n  // they need the current value.  Note: the callbacks will not\n  // be reactive - they will not re-run the instant state changes,\n  // but they *will* see the current value whenever they do run\n\n  speechStateRef.current = speechState;\n  react_1.useEffect(function () {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) {\n      var button = buttonRef.current;\n      button.onholdstart = tangentPressAction;\n      button.onholdend = tangentReleaseAction;\n    }\n  }); // Change button face according to Speechly states\n\n  react_1.useEffect(function () {\n    setIcon(speechState); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [speechState]);\n\n  var tangentPressAction = function () {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentPress, {\n      state: speechStateRef.current\n    });\n\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Idle:\n      case react_client_1.SpeechState.Failed:\n        // Speechly & Mic initialise needs to be in a function triggered by event handler\n        // otherwise it won't work reliably on Safari iOS as of 11/2020\n        initialise().catch(function (err) {\n          return console.error('Error initiasing Speechly', err);\n        });\n        break;\n\n      case react_client_1.SpeechState.Ready:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while starting to record', err);\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  var tangentReleaseAction = function (e) {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentRelease, {\n      state: speechStateRef.current,\n      timeMs: e.timeMs\n    });\n\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Recording:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while stopping recording', err);\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  return react_1.default.createElement(\"div\", null, react_1.default.createElement(\"holdable-button\", {\n    ref: buttonRef,\n    capturekey: captureKey,\n    icon: icon,\n    size: size,\n    gradientstop1: gradientStops[0],\n    gradientstop2: gradientStops[1]\n  }), react_1.default.createElement(HintCallout_1.HintCallout, null));\n};\n\nexports.PushToTalkButton = PushToTalkButton;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACAA;;AA0CO,IAAMC,gBAAgB,GAAoC,UAACC,EAAD,EAIhE;MAHCC,UAAU;MACVC;MAAAC,IAAI,mBAAG,QAAH,GAAWD;MACfE;MAAAC,aAAa,mBAAG,CAAC,SAAD,EAAY,SAAZ,CAAH,GAAyBD;;AAEhC,WAA+CE,iCAA/C;AAAA,MAAEC,WAAW,iBAAb;AAAA,MAAeC,eAAe,qBAA9B;AAAA,MAAgCC,UAAU,gBAA1C;;AACA,WAAkBC,iBAAiBJ,2BAAYK,IAA7B,CAAlB;AAAA,MAACC,IAAI,QAAL;AAAA,MAAOC,OAAO,QAAd;;AACN,MAAMC,SAAS,GAAGJ,gBAAlB;AACA,MAAMK,cAAc,GAAGL,gBAAvB,CAJD,CAMC;AACA;AACA;AACA;AACA;;AACAK,gBAAc,CAACC,OAAf,GAAyBT,WAAzB;AAEAG,oBAAU;AACR;AACA,QAAII,SAAS,SAAT,aAAS,WAAT,GAAS,MAAT,YAAS,CAAEE,OAAf,EAAwB;AACtB,UAAMC,MAAM,GAAGH,SAAS,CAACE,OAAzB;AACAC,YAAM,CAACC,WAAP,GAAqBC,kBAArB;AACAF,YAAM,CAACG,SAAP,GAAmBC,oBAAnB;AACD;AACF,GAPD,EAbD,CAsBC;;AACAX,oBAAU;AACRG,WAAO,CAACN,WAAD,CAAP,CADQ,CAEV;AACC,GAHD,EAGG,CAACA,WAAD,CAHH;;AAKA,MAAMY,kBAAkB,GAAG;AACzBG,wBAAOC,OAAP,CAAeC,yBAAiBC,YAAhC,EAA8C;AAAEC,WAAK,EAAEX,cAAc,CAACC;AAAxB,KAA9C;;AACA,YAAQD,cAAc,CAACC,OAAvB;AACE,WAAKV,2BAAYK,IAAjB;AACA,WAAKL,2BAAYqB,MAAjB;AACE;AACA;AACAlB,kBAAU,GAAGmB,KAAb,CAAmB,eAAG;AAAI,wBAAO,CAACC,KAAR,CAAc,2BAAd,EAA2CC,GAA3C;AAA+C,SAAzE;AACA;;AACF,WAAKxB,2BAAYyB,KAAjB;AACEvB,uBAAe,GAAGoB,KAAlB,CAAwB,eAAG;AAAI,wBAAO,CAACC,KAAR,CAAc,gCAAd,EAAgDC,GAAhD;AAAoD,SAAnF;AACA;;AACF;AACE;AAXJ;AAaD,GAfD;;AAiBA,MAAMT,oBAAoB,GAAG,UAACW,CAAD,EAAO;AAClCV,wBAAOC,OAAP,CAAeC,yBAAiBS,cAAhC,EAAgD;AAAEP,WAAK,EAAEX,cAAc,CAACC,OAAxB;AAAiCkB,YAAM,EAAEF,CAAC,CAACE;AAA3C,KAAhD;;AAEA,YAAQnB,cAAc,CAACC,OAAvB;AACE,WAAKV,2BAAY6B,SAAjB;AACE3B,uBAAe,GAAGoB,KAAlB,CAAwB,eAAG;AAAI,wBAAO,CAACC,KAAR,CAAc,gCAAd,EAAgDC,GAAhD;AAAoD,SAAnF;AACA;;AACF;AACE;AALJ;AAOD,GAVD;;AAYA,SACEpB,2CACEA;AAAiB0B,OAAG,EAAEtB,SAAtB;AAAiCuB,cAAU,EAAEpC,UAA7C;AAAyDW,QAAI,EAAEA,IAA/D;AAAqET,QAAI,EAAEA,IAA3E;AAAiFmC,iBAAa,EAAEjC,aAAa,CAAC,CAAD,CAA7G;AAAkHkC,iBAAa,EAAElC,aAAa,CAAC,CAAD;AAA9I,IADF,EAEEK,8BAAC8B,yBAAD,EAAY,IAAZ,CAFF,CADF;AAMD,CAnEM;;AAAMC,2BAAgB1C,gBAAhB","names":["require","PushToTalkButton","_a","captureKey","_b","size","_c","gradientStops","react_client_1","speechState","toggleRecording","initialise","react_1","Idle","icon","setIcon","buttonRef","speechStateRef","current","button","onholdstart","tangentPressAction","onholdend","tangentReleaseAction","pubsub_js_1","publish","types_1","TangentPress","state","Failed","catch","error","err","Ready","e","TangentRelease","timeMs","Recording","ref","capturekey","gradientstop1","gradientstop2","HintCallout_1","exports"],"sources":["../../src/components/PushToTalkButton.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}